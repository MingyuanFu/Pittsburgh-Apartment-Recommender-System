from rent_cafe_scraper import house_scraper
from open_table_scraper import generate_restaurant_score
from googleMapApi import googleMapApi
from util import *
import numpy as np
import user_interface
from tqdm import tqdm
import time
import sys


def match_house(search_zipcode, price_ceiling):
    house_df = house_scraper()
    sorted_out = house_df[(house_df['price'] < float(price_ceiling)) & (house_df['zipcode'].isin(search_zipcode))]
    house_list = sorted_out.values.tolist()
    return house_list


def generate_zipcode(neigh):
    neigh_zip = {1: [15290, 15222, 15212, 15219], 2: [15213, 15260], 3: [15224, 15206, 15232], 4: [15217]}
    search_zipcode = []
    for num in neigh:
        search_zipcode.extend(neigh_zip[num])
    return search_zipcode


def search_restaurant(house_list,
                      filter_by_distance=True,
                      search_range=3,
                      sort=True,
                      top_k=100,
                      save_csv=False,
                      offline_save=True):
    """Scraping restaurant information from opentable.com and calculate restaurant score for each house

    :param house_list: All of the house information in a list
    :param filter_by_distance: Whether to filter restaurants by their distance to each house
    :param search_range: The distance range for filtering by distance, IN MILE !!
    :param sort: For each restaurant dataframe, whether sort the restaurants by their scores
    :param top_k: For each restaurant dataframe, only return restaurants with highest k score
    :param save_csv: Whether save each restaurant dataframes as csv file
    :param offline_save: Whether save restaurant score of each house in a text file for offline mode
    """
    # house_list is the list generated by match_house function

    scores = []
    house_names = []
    rest_dfs = []
    csv_path = r"restaurant_csv"
    check_path(csv_path)
    time.sleep(0.05)
    house_gen = tqdm(house_list, desc="Searching for restaurants", file=sys.stdout)

    for house in house_gen:
        house_latitude, house_longitude = house[1], house[2]
        house_name = house[0]
        csv_name = "%s_restaurants.csv" % house_name
        save_path = csv_path + "/" + csv_name
        rest_score, rest_df = generate_restaurant_score(house_latitude, house_longitude, filter_by_distance,
                                                        search_range, sort, top_k, save_csv, save_path)

        scores.append(rest_score)
        house_names.append(house_name)
        rest_dfs.append(rest_df)

    scores = np.array(scores)
    scores = normalize(scores)
    # The restaurant part of score for each house with house name is in `rest_scores`
    rest_scores = list(zip(house_names, list(scores)))

    offline_path = "restaurant_score_offline.txt"
    if offline_save:
        write_content = ["%s %f" % (house_name, score) for house_name, score in rest_scores]
        with open(offline_path, "w") as file:
            file.writelines(write_content)
    return rest_scores, rest_dfs


def measure_transit_scores(house_list, school_company, transit_mode, goog_map_api):
    scores = []
    house_names = []
    commute_coord = goog_map_api.get_coordinator_by_address(school_company)
    transit_gen = tqdm(house_list, desc="Searching for transit", file=sys.stdout)
    for house in transit_gen:
        house_coord = (house[1], house[2])
        score = goog_map_api.calculate_transportation_score(house_coord, commute_coord, transit_mode)
        scores.append(score)
        house_names.append(house[0])

    transit_scores = list(zip(house_names, list(scores)))
    return transit_scores


def measure_entertain_scores(house_list, goog_map_api):
    scores = []
    house_names = []
    entertain_gen = tqdm(house_list, desc="Searching for entertainment", file=sys.stdout)
    for house in entertain_gen:
        house_coord = (house[1], house[2])
        score = goog_map_api.calculate_entertainment_score(house_coord)
        scores.append(score)
        house_names.append(house[0])

    scores = np.array(scores)
    scores = normalize(scores)
    entertain_scores = list(zip(house_names, list(scores)))
    return entertain_scores


def cal_final_score(house_list, rest_scores, entertain_scores, trans_scores, ranking):
    house_dic = {}
    percentage = [aspect / 100 for aspect in ranking]
    for house in house_list:
        if percentage[0] != 0:
            for res in rest_scores:
                if house[0] == res[0]:
                    house_dic[house[0]] = percentage[0] * res[1]
        else:
            house_dic[house[0]] = 0

        if percentage[1] != 0:
            for entertain in entertain_scores:
                if house[0] == entertain[0]:
                    house_dic[house[0]] += percentage[1] * entertain[1]

        if percentage[2] != 0:
            for trans in trans_scores:
                if house[0] == trans[0]:
                    house_dic[house[0]] += percentage[2] * trans[1]
    print("\n\nHere is the house ranking we prepared for you!\n")
    house_dic = dict(sorted(house_dic.items(), key=lambda item: item[1], reverse=True))
    count = 1
    for h in house_dic.keys():
        print(str(count) + ". " + h + " | score: %.2f" % house_dic[h])
        count += 1
    return house_dic


def plot_map(house, school_company, goog_map_api):
    house_coord = (house[1], house[2])
    commute_coord = goog_map_api.get_coordinator_by_address(school_company)
    goog_map_api.gmPlotter_init(house_coord)
    goog_map_api.add_plotter_marker(commute_coord, 'blue')
    goog_map_api.draw_and_display_gm_plot()


def show_restaurants(rest_df, house_name):

    restaurant_num = 20 if rest_df.shape[0] >= 20 else rest_df.shape[0]

    def handle_input():
        input_str = input("\nDo you want to check out the restaurants around {}? Input 'yes' to proceed, "
                          "input 'no' to pass.\n".format(house_name))
        return check_yes_no(input_str)

    def show_rest_info(row):
        print("\nRestaurant name: {}".format(row["name"]))
        print("Restaurant price band: {}".format(row["priceBand"]))
        print("Restaurant cuisines: {}".format(row["primaryCuisine"]))
        print("Cell: {}".format(row["contactInformation"]))
        print("Restaurant address: {}".format(row["address"]))
        print("Has bar: {}".format("Yes" if row["hasBar"] else "No"))
        print("Has outdoor: {}".format("Yes" if row["hasOutdoor"] else "No"))
        print("Delivery partner: {}".format(row["deliveryPartners"] if row["deliveryPartners"] else "Not Available"))
        print("Neighborhood: {}".format(row["neighborhood"]))
        print("OpenTable rating: {}".format(row["ratings"]))

    if handle_input():
        print("\n\nHere are the top {} restaurants with highest scores around {}:\n".format(restaurant_num, house_name))
        print("No.  %-60s     %-30s     %-10s" % ("Restaurant Name", "Cuisine", "Price Band"))
        print("------------------------------------------------------------------------------------------------------"
              "----------------")
        for i in range(0, restaurant_num):
            row = rest_df.loc[i]
            print("%2d. %-60s     %-30s     %-10s" % (i+1, row["name"], row["primaryCuisine"], row["priceBand"]))

        rest_index = input("\nPlease input 1 to {} to check the detailed information of one restaurant. "
                           "Input any other characters to quit.\n".format(restaurant_num))
        while rest_index in [str(num) for num in range(1, restaurant_num+1)]:
            show_rest_info(rest_df.loc[int(rest_index)-1])
            rest_index = input("\nPlease input 1 to {} to see check detailed information of one restaurant. "
                               "Input any other characters to check another house.\n".format(restaurant_num))
    else:
        pass


def main():
    print("--------------------------------------  Welcome To Pillow  --------------------------------------")
    res, shopping, trans = user_interface.handle_user_input()
    print("\nThank you for setting your preferences. Now, Pillow will help you to pick a neighborhood.")
    neigh = user_interface.display_neighborhood()
    print(
        "\nThank you for choosing the neighborhoods. Now please set your acceptable price range. Enter 'No' if you "
        "don't care about price:")
    price_ceiling = user_interface.handle_price()
    print(
        "\nCould you please provide the address of your company or school? e.g. 'Heinz college' or 'CMU'")
    school_company, transit_mode = user_interface.handle_daily_commute()
    print(
        "\nYou are all set. Pillow is calculating your preference and choosing the most suitable housing for you.\n"
    )

    print("\nStart scraping from Rent Cafe...")
    zipcode_list = generate_zipcode(neigh)
    house_list = match_house(zipcode_list, price_ceiling)

    print("\n(AD) Apply for CMU Heinz College MISM-BIDA!\nWithin the MISM program, the Business Intelligence & "
          "Data Analytics (BIDA) pathway goes deeper into the emerging field of analytics,\nforging experts that change"
          " the way companies do business around the world. \nAnd you will learn a LOT in DFP, a required course in"
          " MISM-BIDA.\n\nMore info: https://www.heinz.cmu.edu/programs/information-systems-management-master/bida")

    if res > 0:
        print("\n\nMeasuring nearby restaurants from Open Table...")
        res_scores, rest_dfs = search_restaurant(house_list)
    else:
        print("\n\nRestaurant searching will be skipped, since your preference for restaurants is 0.")
        res_scores = [0 for _ in house_list]
        rest_dfs = None

    time.sleep(0.2)

    gma = googleMapApi()
    if trans > 0:
        print("\n\nMeasuring transit from Google Map Distance...")
        trans_scores = measure_transit_scores(house_list, school_company, transit_mode, gma)
    else:
        print("\n\nTransit searching will be skipped, since your preference for transit is 0.")
        trans_scores = [0 for _ in house_list]

    time.sleep(0.2)

    if shopping > 0:
        print("\n\nMeasuring nearby entertainments from Google Map Places...")
        entertain_scores = measure_entertain_scores(house_list, gma)
    else:
        print("\n\nEntertainment searching will be skipped, since your preference for entertainment is 0.")
        entertain_scores = [0 for _ in house_list]

    iter_flag = True

    while iter_flag:
        house_dict = cal_final_score(house_list, res_scores, entertain_scores, trans_scores, [res, shopping, trans])

        index = input("\nWhich apartment/house are you interest in? Please Input the index number.\n")
        index = check_numerical_input(index, mode="int", min_input=1, max_input=len(house_dict))
        idx = int(index) - 1

        m = input("\nWould you want me to show it on a map? Input 'yes' to proceed, input 'no' to pass.\n")
        show_map = check_yes_no(m)

        if show_map:
            for index, house in enumerate(house_list):
                if house[0] == list(house_dict.keys())[idx]:
                    plot_map(house, school_company, gma)
                    break

        if res > 0:
            show_restaurants(rest_dfs[0], list(house_dict.keys())[idx])

        repeat = input("\nDo you want to check another house? Input 'Yes' to check another house. "
                       "Input 'No' to quit.\n")
        iter_flag = check_yes_no(repeat)

    print("\nThank you for using Pillow!")


if __name__ == '__main__':
    main()
